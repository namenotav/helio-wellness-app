class o{constructor(){this.encryptionKey=null,this.algorithm="AES-GCM"}async initialize(){try{let t=localStorage.getItem("__encryption_key__");if(t)this.encryptionKey=await this.importKey(t);else{const e=await this.generateKey();t=await this.exportKey(e),localStorage.setItem("__encryption_key__",t),this.encryptionKey=e}return!0}catch{return!1}}async generateKey(){return await crypto.subtle.generateKey({name:this.algorithm,length:256},!0,["encrypt","decrypt"])}async exportKey(t){const e=await crypto.subtle.exportKey("raw",t);return this.arrayBufferToBase64(e)}async importKey(t){const e=this.base64ToArrayBuffer(t);return await crypto.subtle.importKey("raw",e,{name:this.algorithm},!0,["encrypt","decrypt"])}async encrypt(t){try{this.encryptionKey||await this.initialize();const e=JSON.stringify(t),r=new TextEncoder().encode(e),a=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({name:this.algorithm,iv:a},this.encryptionKey,r),c=new Uint8Array(a.length+i.byteLength);return c.set(a,0),c.set(new Uint8Array(i),a.length),this.arrayBufferToBase64(c)}catch{return null}}async decrypt(t){try{this.encryptionKey||await this.initialize();const e=this.base64ToArrayBuffer(t),n=e.slice(0,12),r=e.slice(12),a=await crypto.subtle.decrypt({name:this.algorithm,iv:n},this.encryptionKey,r),c=new TextDecoder().decode(a);return JSON.parse(c)}catch{return null}}arrayBufferToBase64(t){const e=new Uint8Array(t);let n="";for(let r=0;r<e.length;r++)n+=String.fromCharCode(e[r]);return btoa(n)}base64ToArrayBuffer(t){const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e.charCodeAt(r);return n}async setSecureItem(t,e){const n=await this.encrypt(e);return n?(localStorage.setItem(`secure_${t}`,n),!0):!1}async getSecureItem(t){const e=localStorage.getItem(`secure_${t}`);return e?await this.decrypt(e):null}removeSecureItem(t){localStorage.removeItem(`secure_${t}`)}}const y=new o;export{y as default};
